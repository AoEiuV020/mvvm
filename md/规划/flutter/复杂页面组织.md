# Flutter 复杂页面组织

## 何时拆分 ViewModel

| 情况 | 方案 |
|------|------|
| 页面功能单一 | 单个 ViewModel |
| 页面有独立子模块 | 多个 ViewModel |
| 可复用的功能块 | 独立 ViewModel |

## 多 ViewModel 模式

```dart
// 主页面 ViewModel
@riverpod
class ChatViewModel extends _$ChatViewModel {
  @override
  ChatState build(String conversationId) => ChatState();
  
  // 消息列表相关
}

// 输入栏独立 ViewModel
@riverpod
class ChatInputViewModel extends _$ChatInputViewModel {
  @override
  ChatInputState build(String conversationId) => ChatInputState();
  
  // 输入、发送相关
}

// 消息操作独立 ViewModel
@riverpod
class MessageActionViewModel extends _$MessageActionViewModel {
  @override
  MessageActionState build() => MessageActionState();
  
  // 复制、转发、删除相关
}
```

## View 组合

```dart
class ChatPage extends ConsumerWidget {
  final String conversationId;
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Column(
      children: [
        Expanded(child: MessageList(conversationId: conversationId)),
        ChatInputBar(conversationId: conversationId),
      ],
    );
  }
}

class MessageList extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(chatViewModelProvider(conversationId));
    // ...
  }
}

class ChatInputBar extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(chatInputViewModelProvider(conversationId));
    // ...
  }
}
```

## ViewModel 间通信

```dart
@riverpod
class ChatInputViewModel extends _$ChatInputViewModel {
  Future<void> sendMessage() async {
    // 发送消息后刷新消息列表
    await ref.read(messageServiceProvider).sendMessage(...);
    
    // 使主列表刷新
    ref.invalidate(chatViewModelProvider(state.conversationId));
  }
}
```

## 拆分原则

1. 每个 ViewModel 只负责一个关注点
2. ViewModel 之间通过 `ref.read()` 或 `ref.invalidate()` 通信
3. 共享数据放在独立的 Provider 中
4. 避免 ViewModel 之间直接持有引用

---

## 同一 View 多种 ViewModel 实现

**适用场景：** UI 结构相似但业务逻辑差异大的页面变体（如单聊/群聊）

### 设计模式：统一接口 + 多实现 + Mixin 复用

**接口设计原则：**

| 状态类型 | 处理方式 |
|----------|----------|
| 共同状态 | 定义为普通属性 |
| 仅部分变体拥有的状态 | 定义为可空类型，其他变体返回 null |
| 类型标识 | 暴露枚举属性 |

### 接口定义

```dart
abstract interface class IXxxViewModel {
  XxxType get type;
  
  // 共同状态
  List<Item> get items;
  bool get isLoading;
  
  // 差异状态 - 某变体独有，其他返回 null
  String? get variantOnlyData;
  
  // 共同操作
  Future<void> loadData();
}
```

### 依赖注入规范

Model 层依赖在 `build` 方法中一次性注入，不在其他方法中使用 `ref.read`：

```dart
@riverpod
class TypeAViewModel extends _$TypeAViewModel implements IXxxViewModel {
  late final IXxxRepository _repo;
  late final IYyyService _service;
  
  @override
  XxxState build(String id) {
    // 一次性注入所有 Model 层依赖
    _repo = ref.read(xxxRepoProvider);
    _service = ref.read(yyyServiceProvider);
    return XxxState();
  }
  
  @override
  Future<void> loadData() async {
    // 直接使用已注入的依赖
    final data = await _repo.fetchData(id);
    state = state.copyWith(items: data);
  }
}
```

### 共同逻辑复用

多个 ViewModel 实现之间的重复代码通过 Mixin 复用：

```dart
/// 分页加载 Mixin - ViewModel 层代码复用
mixin PaginatedListMixin<T> {
  // 由宿主类提供
  List<T> get items;
  bool get isLoading;
  void updateState({List<T>? items, bool? isLoading, String? error});
  
  /// 通用分页加载逻辑
  Future<void> loadMoreWith(Future<List<T>> Function() fetcher) async {
    updateState(isLoading: true);
    try {
      final newItems = await fetcher();
      updateState(items: [...items, ...newItems], isLoading: false);
    } catch (e) {
      updateState(isLoading: false, error: e.toString());
    }
  }
}

/// ViewModel 使用 Mixin
@riverpod
class TypeAViewModel extends _$TypeAViewModel
    with PaginatedListMixin<Item>
    implements IXxxViewModel {
  
  late final IXxxRepository _repo;
  
  @override
  XxxState build(String id) {
    _repo = ref.read(xxxRepoProvider);
    return XxxState();
  }
  
  // 实现 Mixin 要求的抽象成员
  @override
  List<Item> get items => state.items;
  @override
  bool get isLoading => state.isLoading;
  @override
  void updateState({List<Item>? items, bool? isLoading, String? error}) {
    state = state.copyWith(items: items, isLoading: isLoading, error: error);
  }
  
  @override
  Future<void> loadData() => loadMoreWith(() => _repo.fetchData(id));
}
```

**Mixin 使用原则：**
- Mixin 仅封装 ViewModel 层的状态操作模式
- 不持有状态，通过抽象成员访问宿主状态
- 不包含 Model 层逻辑

### View 层使用

```dart
// 可空判断实现条件渲染
if (vm.variantOnlyData case final data?) {
  VariantWidget(data: data);
}
```

### 禁止行为

- ❌ `vm is TypeAViewModel` 类型判断
- ❌ 强制类型转换
- ❌ 抽象基类继承
- ❌ 在 `build` 以外使用 `ref.read` 获取依赖
- ❌ 在 getter 中使用 `ref.watch`
