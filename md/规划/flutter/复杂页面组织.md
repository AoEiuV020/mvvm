# Flutter 复杂页面组织

## 何时拆分 ViewModel

| 情况 | 方案 |
|------|------|
| 页面功能单一 | 单个 ViewModel |
| 页面有独立子模块 | 多个 ViewModel |
| 可复用的功能块 | 独立 ViewModel |

## 多 ViewModel 模式

```dart
// 主页面 ViewModel
@riverpod
class ChatViewModel extends _$ChatViewModel {
  @override
  ChatState build(String conversationId) => ChatState();
  
  // 消息列表相关
}

// 输入栏独立 ViewModel
@riverpod
class ChatInputViewModel extends _$ChatInputViewModel {
  @override
  ChatInputState build(String conversationId) => ChatInputState();
  
  // 输入、发送相关
}

// 消息操作独立 ViewModel
@riverpod
class MessageActionViewModel extends _$MessageActionViewModel {
  @override
  MessageActionState build() => MessageActionState();
  
  // 复制、转发、删除相关
}
```

## View 组合

```dart
class ChatPage extends ConsumerWidget {
  final String conversationId;
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Column(
      children: [
        Expanded(child: MessageList(conversationId: conversationId)),
        ChatInputBar(conversationId: conversationId),
      ],
    );
  }
}

class MessageList extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(chatViewModelProvider(conversationId));
    // ...
  }
}

class ChatInputBar extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(chatInputViewModelProvider(conversationId));
    // ...
  }
}
```

## ViewModel 间通信

```dart
@riverpod
class ChatInputViewModel extends _$ChatInputViewModel {
  Future<void> sendMessage() async {
    // 发送消息后刷新消息列表
    await ref.read(messageServiceProvider).sendMessage(...);
    
    // 使主列表刷新
    ref.invalidate(chatViewModelProvider(state.conversationId));
  }
}
```

## 拆分原则

1. 每个 ViewModel 只负责一个关注点
2. ViewModel 之间通过 `ref.read()` 或 `ref.invalidate()` 通信
3. 共享数据放在独立的 Provider 中
4. 避免 ViewModel 之间直接持有引用
