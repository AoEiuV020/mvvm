# Flutter 复杂页面组织

## 何时拆分 ViewModel

| 情况 | 方案 |
|------|------|
| 页面功能单一 | 单个 ViewModel |
| 页面有独立子模块 | 多个 ViewModel |
| 可复用的功能块 | 独立 ViewModel |

## 多 ViewModel 模式

```dart
// 主页面 ViewModel
@riverpod
class ChatViewModel extends _$ChatViewModel {
  @override
  ChatState build(String conversationId) => ChatState();
  
  // 消息列表相关
}

// 输入栏独立 ViewModel
@riverpod
class ChatInputViewModel extends _$ChatInputViewModel {
  @override
  ChatInputState build(String conversationId) => ChatInputState();
  
  // 输入、发送相关
}

// 消息操作独立 ViewModel
@riverpod
class MessageActionViewModel extends _$MessageActionViewModel {
  @override
  MessageActionState build() => MessageActionState();
  
  // 复制、转发、删除相关
}
```

## View 组合

```dart
class ChatPage extends ConsumerWidget {
  final String conversationId;
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Column(
      children: [
        Expanded(child: MessageList(conversationId: conversationId)),
        ChatInputBar(conversationId: conversationId),
      ],
    );
  }
}

class MessageList extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(chatViewModelProvider(conversationId));
    // ...
  }
}

class ChatInputBar extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(chatInputViewModelProvider(conversationId));
    // ...
  }
}
```

## ViewModel 间通信

```dart
@riverpod
class ChatInputViewModel extends _$ChatInputViewModel {
  Future<void> sendMessage() async {
    // 发送消息后刷新消息列表
    await ref.read(messageServiceProvider).sendMessage(...);
    
    // 使主列表刷新
    ref.invalidate(chatViewModelProvider(state.conversationId));
  }
}
```

## 拆分原则

1. 每个 ViewModel 只负责一个关注点
2. ViewModel 之间通过 `ref.read()` 或 `ref.invalidate()` 通信
3. 共享数据放在独立的 Provider 中
4. 避免 ViewModel 之间直接持有引用

---

## 同一 View 多种 ViewModel 实现

**适用场景：** UI 结构相似但业务逻辑差异大的页面变体（如单聊/群聊）

### 设计模式：统一接口 + 多实现 + 共同逻辑组合

**接口设计原则：**

| 状态类型 | 处理方式 |
|----------|----------|
| 共同状态 | 定义为普通属性 |
| 仅部分变体拥有的状态 | 定义为可空类型，其他变体返回 null |
| 类型标识 | 暴露枚举属性 |

### 接口定义示例

```dart
abstract interface class IXxxViewModel {
  XxxType get type;
  
  // 共同状态
  List<Item> get items;
  bool get isLoading;
  
  // 差异状态 - 某变体独有，其他返回 null
  String? get variantOnlyData;
  
  // 共同操作
  Future<void> loadData();
}
```

### 共同逻辑复用

将共同逻辑封装为独立 Provider，各 ViewModel 通过 `ref.watch`/`ref.read` 组合使用：

```dart
/// 共同逻辑 Provider
@riverpod
class SharedLogicManager extends _$SharedLogicManager { ... }

/// ViewModel 实现 - 组合共同逻辑
@riverpod
class TypeAViewModel extends _$TypeAViewModel implements IXxxViewModel {
  // 委托给共同逻辑 Provider
  @override
  List<Item> get items => ref.watch(sharedLogicManagerProvider).items;
  
  // 差异状态
  @override
  String? get variantOnlyData => null;
}
```

### View 层使用

```dart
// 可空判断实现条件渲染
if (vm.variantOnlyData case final data?) {
  VariantWidget(data: data);
}
```

### 禁止行为

- ❌ `vm is TypeAViewModel` 类型判断
- ❌ 强制类型转换
- ❌ 抽象基类继承（用组合代替）
