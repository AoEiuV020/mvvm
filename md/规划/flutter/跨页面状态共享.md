# 跨页面状态共享

基于[通用跨页面状态共享](../通用/跨页面状态共享.md)原则，Flutter 使用 Family Provider 实现。

## 场景

多个页面依赖同一份数据，且数据需要实时同步：

- 群聊页、群设置页、群管理页共享同一份 GroupInfo
- SDK 实时推送更新（禁言状态、权限变更等）
- 各页面实时响应

## 方案：Family Provider

使用 `@riverpod` 的 Family 特性，相同参数返回同一 Provider 实例。

### ViewModel 定义

```dart
@riverpod
class GroupInfoViewModel extends _$GroupInfoViewModel {
  @override
  GroupInfoState build(String groupId) {
    // 监听 SDK 实时更新
    final subscription = ref.read(groupServiceProvider).watchGroup(groupId).listen((info) {
      state = state.copyWith(groupInfo: info);
    });
    ref.onDispose(() => subscription.cancel());
    
    // 初始加载
    _loadGroupInfo();
    
    return GroupInfoState(groupId: groupId);
  }
  
  Future<void> _loadGroupInfo() async {
    final info = await ref.read(groupServiceProvider).getGroupInfo(groupId);
    state = state.copyWith(groupInfo: info);
  }
}
```

### 页面使用

```dart
// 群聊页
class GroupChatPage extends ConsumerWidget {
  final String groupId;
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final groupState = ref.watch(groupInfoViewModelProvider(groupId));
    // 使用 groupState.groupInfo
  }
}

// 群设置页
class GroupSettingsPage extends ConsumerWidget {
  final String groupId;
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final groupState = ref.watch(groupInfoViewModelProvider(groupId));
    // 使用 groupState.groupInfo，与群聊页共享同一实例
  }
}
```

## 工作原理

1. 多个页面调用 `ref.watch(groupInfoViewModelProvider(groupId))`
2. 相同 `groupId` → Riverpod 返回同一 Provider 实例
3. Provider 内部监听 SDK Stream
4. SDK 推送更新 → `state = state.copyWith(...)` → 所有页面自动刷新

## 生命周期

- 第一个页面 watch 时创建 Provider
- 最后一个页面离开后，Provider 销毁、取消订阅
- 重新进入时重新创建

## keepAlive 保持

如需保持状态不被销毁：

```dart
@Riverpod(keepAlive: true)
class GroupInfoViewModel extends _$GroupInfoViewModel {
  // ...
}
```

适用场景：频繁切换的页面、需要后台持续监听的数据。
