# Flutter 状态管理

## Provider 类型选择

| 场景 | Provider 类型 |
|------|---------------|
| SDK 服务（单例） | `Provider` |
| ViewModel | `@riverpod` + `Notifier` |
| 带参数的 ViewModel | `@riverpod` + `FamilyNotifier` |
| 异步数据 | `@riverpod` + `AsyncNotifier` |

## 生命周期管理

Riverpod 提供的生命周期钩子：

```dart
@riverpod
class XxxViewModel extends _$XxxViewModel {
  @override
  XxxState build() {
    // 初始化时机
    ref.onDispose(() {
      // 销毁时机：取消订阅、释放资源
    });
    return const XxxState();
  }
}
```

直接使用 Riverpod 提供的机制，不定义额外基类。

## 状态类（freezed）

freezed 3.x 使用 `abstract class` 语法：

```dart
@freezed
abstract class XxxState with _$XxxState {
  const factory XxxState({
    @Default('') String field,
    @Default(false) bool isLoading,
    String? errorMessage,
  }) = _XxxState;
}
```

## ViewModel 实现（@riverpod）

```dart
@riverpod
class XxxViewModel extends _$XxxViewModel {
  @override
  XxxState build() => const XxxState();
  
  void setField(String value) {
    state = state.copyWith(field: value, errorMessage: null);
  }
  
  Future<bool> doAction() async {
    state = state.copyWith(isLoading: true);
    
    final service = ref.read(xxxServiceProvider);
    final result = await service.action();
    
    state = state.copyWith(
      isLoading: false,
      errorMessage: result.success ? null : '操作失败',
    );
    
    return result.success;
  }
}
```

## 普通 Provider（非 Notifier）

riverpod 4.x 中，普通 Provider 使用 `Ref` 类型（来自 riverpod_annotation）：

```dart
import 'package:riverpod_annotation/riverpod_annotation.dart';

@Riverpod(keepAlive: true)
IAuthService authService(Ref ref) {
  throw UnimplementedError('must be overridden');
}
```

**注意：** 不需要额外导入 `flutter_riverpod`，`Ref` 由 `riverpod_annotation` 提供。

## 带参数的 ViewModel

```dart
@riverpod
class ChatViewModel extends _$ChatViewModel {
  @override
  ChatState build(String conversationId) => ChatState(conversationId: conversationId);
  
  // ...
}

// 使用
ref.watch(chatViewModelProvider(conversationId));
```

## View 中使用

```dart
class XxxPage extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(xxxViewModelProvider);
    final vm = ref.read(xxxViewModelProvider.notifier);
    
    // state.field 访问状态
    // vm.setField() 调用方法
  }
}
```
3. 异步操作前后都要更新 loading 状态
