# Flutter 状态管理

## Provider 类型选择

| 场景 | Provider 类型 |
|------|---------------|
| SDK 服务（单例） | `Provider` |
| ViewModel | `@riverpod` + `Notifier` |
| 带参数的 ViewModel | `@riverpod` + `FamilyNotifier` |
| 异步数据 | `@riverpod` + `AsyncNotifier` |

## 状态类（freezed）

```dart
@freezed
class XxxState with _$XxxState {
  const factory XxxState({
    @Default('') String field,
    @Default(false) bool isLoading,
    String? errorMessage,
  }) = _XxxState;
}
```

## ViewModel 实现（@riverpod）

```dart
@riverpod
class XxxViewModel extends _$XxxViewModel {
  @override
  XxxState build() => const XxxState();
  
  void setField(String value) {
    state = state.copyWith(field: value, errorMessage: null);
  }
  
  Future<bool> doAction() async {
    state = state.copyWith(isLoading: true);
    
    final service = ref.read(xxxServiceProvider);
    final result = await service.action();
    
    state = state.copyWith(
      isLoading: false,
      errorMessage: result.success ? null : '操作失败',
    );
    
    return result.success;
  }
}
```

## 带参数的 ViewModel

```dart
@riverpod
class ChatViewModel extends _$ChatViewModel {
  @override
  ChatState build(String conversationId) => ChatState(conversationId: conversationId);
  
  // ...
}

// 使用
ref.watch(chatViewModelProvider(conversationId));
```

## View 中使用

```dart
class XxxPage extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(xxxViewModelProvider);
    final vm = ref.read(xxxViewModelProvider.notifier);
    
    // state.field 访问状态
    // vm.setField() 调用方法
  }
}
```
3. 异步操作前后都要更新 loading 状态
