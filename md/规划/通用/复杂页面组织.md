# 复杂页面组织

## 大页面拆分原则

当页面逻辑过于复杂时，按功能区域拆分为多个子组件。

**拆分条件：**
- 页面代码超过 500 行
- 存在多个独立的功能区域
- 需要复用部分 UI 组件

## 组件划分

| 类型 | 说明 |
|------|------|
| 主页面 | 负责整体布局和状态管理 |
| 子组件 | 负责特定区域的展示和交互 |
| 公共组件 | 可跨页面复用的 UI 组件 |

## 状态管理策略

- 主 ViewModel 管理页面级状态
- 子组件通过参数接收所需状态
- 子组件事件通过回调传递给主页面

## 子组件独立 ViewModel

当子组件具有独立业务逻辑时，可拥有独立 ViewModel：
- 子 ViewModel 由主 ViewModel 持有或通过依赖注入获取
- 子 ViewModel 处理局部状态和业务逻辑

## 禁止行为

- 子组件直接访问 SDK
- 子组件绕过主页面直接修改全局状态
- 过度拆分导致组件粒度过细

---

## 同一 View 多种 ViewModel 实现

**适用场景：** UI 结构相似但业务逻辑差异大的页面变体（如单聊/群聊、不同类型详情页）

### 设计模式：统一接口 + 多实现 + 代码复用

定义统一的 ViewModel 接口，由多个实现类分别处理不同变体的业务逻辑。

**接口设计原则：**

| 状态类型 | 处理方式 |
|----------|----------|
| 共同状态 | 定义为普通属性 |
| 仅部分变体拥有的状态 | 定义为可空类型，其他变体返回 null |
| 类型标识 | 暴露枚举属性，供 View 判断当前变体 |

**View 层处理差异 UI：**

View 持有统一接口类型，通过可空判断实现条件渲染：
- 读取可空状态
- 非空时渲染对应 UI 组件
- 无需类型转换，无需判断类型枚举

### 依赖注入规范

Model 层依赖（Repository/Service）在 ViewModel 初始化时一次性注入：
- 构造函数或初始化方法中获取所有依赖
- 业务方法中直接使用已注入的依赖
- 不在业务方法中动态获取依赖

### 共同逻辑复用

多个 ViewModel 实现之间的重复代码通过以下方式复用：

**复用层次：**

| 逻辑类型 | 归属层 | 复用方式 |
|----------|--------|----------|
| 数据获取、业务规则 | Model 层 | Service/Repository 接口 |
| 状态操作模式（分页、加载等） | ViewModel 层 | Mixin / 辅助函数 |

**ViewModel 层复用原则：**
- 使用 Mixin（Dart）、组合式函数（Vue）等语言特性
- 复用代码仅封装状态操作模式，不持有状态
- 各 ViewModel 独立持有和管理自己的状态
- 不使用抽象基类继承

### 禁止行为

- ❌ 为每种变体定义独立接口（View 无法统一持有）
- ❌ 在 View 层强制类型转换获取差异数据
- ❌ 使用抽象基类继承复用代码
- ❌ 在业务方法中动态获取 Model 层依赖
