# 复杂页面组织

## 大页面拆分原则

当页面逻辑过于复杂时，按功能区域拆分为多个子组件。

**拆分条件：**
- 页面代码超过 500 行
- 存在多个独立的功能区域
- 需要复用部分 UI 组件

## 组件划分

| 类型 | 说明 |
|------|------|
| 主页面 | 负责整体布局和状态管理 |
| 子组件 | 负责特定区域的展示和交互 |
| 公共组件 | 可跨页面复用的 UI 组件 |

## 状态管理策略

- 主 ViewModel 管理页面级状态
- 子组件通过参数接收所需状态
- 子组件事件通过回调传递给主页面

## 子组件独立 ViewModel

当子组件具有独立业务逻辑时，可拥有独立 ViewModel：
- 子 ViewModel 由主 ViewModel 持有或通过依赖注入获取
- 子 ViewModel 处理局部状态和业务逻辑

## 禁止行为

- 子组件直接访问 SDK
- 子组件绕过主页面直接修改全局状态
- 过度拆分导致组件粒度过细

---

## 同一 View 多种 ViewModel 实现

**适用场景：** UI 结构相似但业务逻辑差异大的页面变体（如单聊/群聊、不同类型详情页）

### 设计模式：统一接口 + 多实现 + 共同逻辑组合

定义统一的 ViewModel 接口，由多个实现类分别处理不同变体的业务逻辑。共同逻辑通过组合复用。

**接口设计原则：**

| 状态类型 | 处理方式 |
|----------|----------|
| 共同状态 | 定义为普通属性 |
| 仅部分变体拥有的状态 | 定义为可空类型，其他变体返回 null |
| 类型标识 | 暴露枚举属性，供 View 判断当前变体 |

**View 层处理差异 UI：**

View 持有统一接口类型，通过可空判断实现条件渲染：
- 读取可空状态
- 非空时渲染对应 UI 组件
- 无需类型转换，无需判断类型枚举

### 共同逻辑复用

多个 ViewModel 实现可能存在相同的业务逻辑（如消息列表管理、数据加载等），通过组合模式复用：

- 将共同逻辑封装为独立的辅助类或子 ViewModel
- 各实现类持有该辅助类实例（组合）
- 接口方法的实现委托给辅助类

**组合优于继承的原因：**
- 各变体依赖的 Model 层（Service/Repository）可能完全不同
- 避免继承层次带来的耦合
- 共同逻辑独立可测

### 禁止行为

- ❌ 为每种变体定义独立接口（View 无法统一持有）
- ❌ 在 View 层强制类型转换获取差异数据
- ❌ 使用抽象基类继承复用代码（用组合代替）
